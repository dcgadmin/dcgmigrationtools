module,description,oracle_sql,postgresql_sql,refcol,dbtovalidate
Database Object Summary,This section shows the count of objects in Oracle and PostgreSQL Database with source Oracle as reference.,"select owner, case when object_type = 'PACKAGE' then 'PACKAGE/SCHEMA' else object_type end object_type, count(*) cnt from dba_objects where owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( OBJECT_name not like 'DR%' and OBJECT_name not like 'BIN$%' and OBJECT_name not like 'MLOG$%' and object_name not like 'I_SNAP$%' ) and ( OBJECT_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') and object_type = 'TABLE' ) ) and TEMPORARY != 'Y' and object_name not in ( select index_name from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and index_type = 'LOB' or ( table_name in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and generated = 'Y' ) ) and object_type in ( 'TABLE', 'INDEX', 'MATERIALIZED_VIEW', 'SEQUENCE', 'VIEW', 'TYPE', 'TRIGGER' ) GROUP BY owner, object_type UNION ( select distinct owner, case when object_type = 'PACKAGE' then 'PACKAGE/SCHEMA' when object_type in ('PROCEDURE', 'FUNCTION') then 'PROCEDURE-FUNCTION' else object_type end object_type, count(object_name) from dba_objects where owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( OBJECT_name not like 'DR%' and OBJECT_name not like 'BIN$%' and OBJECT_name not like 'MLOG$%' and object_name not like 'I_SNAP$%' ) and ( OBJECT_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') and object_type = 'TABLE' ) ) and TEMPORARY != 'Y' and object_name not in ( select index_name from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and index_type = 'LOB' or ( table_name in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and generated = 'Y' ) ) and object_type in ('PACKAGE', 'PROCEDURE', 'FUNCTION') GROUP BY owner,case when object_type = 'PACKAGE' then 'PACKAGE/SCHEMA' when object_type in ('PROCEDURE', 'FUNCTION') then 'PROCEDURE-FUNCTION' else object_type end )","select upper(nspname) as owner, object_type, count(*)::integer cnt from ( select case when ( cls.relkind = 'r' and relispartition = 'no' ) then 'TABLE' when ( cls.relkind = 'r' and relispartition = 'yes' ) then 'TABLE PARTITION' when (cls.relkind = 'p') then 'TABLE' when (cls.relkind = 'f') then 'FOREIGN TABLE' when (cls.relkind = 'm') then 'MATERIALIZED_VIEW' when ( cls.relkind = 'i' and relispartition = 'no' ) then ( select case when ctb.relispartition = 'yes' then 'INDEX PARTITION' else 'INDEX' end from pg_class ctb join pg_index ix on ctb.oid = ix.indrelid join pg_class cix on cix.oid = ix.indexrelid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and cix.relname = cls.relname ) when ( cls.relkind = 'i' and relispartition = 'yes' ) then 'INDEX PARTITION' when (cls.relkind = 'I') then 'INDEX' when (cls.relkind = 'S') then 'SEQUENCE' when (cls.relkind = 'v') then 'VIEW' when (cls.relkind = 'c') then 'TYPE' ELSE cls.relkind :: varchar end as object_Type, * from pg_class cls join pg_namespace nsp ON nsp.oid = cls.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and nsp.nspname not like 'pg_toast%%' ) a GROUP BY nspname, object_type union all select upper(event_object_schema), 'TRIGGER' object_type, count(distinct action_statement) from information_schema.triggers where event_object_schema = lower('<<POSTGRES_SCHEMA_NAME>>') group by upper(event_object_schema) union select upper(nspname), upper(pg.object_type), count(1) from ( select distinct nsp.nspname, case when pr.prokind = 'p' then 'PROCEDURE-FUNCTION' else 'PROCEDURE-FUNCTION' end as object_type from pg_proc pr join pg_namespace nsp on nsp.oid = pr.pronamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') union all select upper('<<POSTGRES_SCHEMA_NAME>>'), 'PACKAGE/SCHEMA' object_type from pg_namespace where nspname not like 'pg_toast%%' and nspname not like 'pg_temp_%%' and nspname not in ( 'pg_toast', 'pg_catalog', 'aws_oracle_ext', 'aws_oracle_data', 'aws_oracle_context', 'information_schema', 'public', lower('<<POSTGRES_SCHEMA_NAME>>') ) ) pg group by upper(nspname), upper(pg.object_type)","owner,object_type",summary
Database Configuration,Database Details,"SELECT upper('<<ORACLE_SCHEMA_NAME>>') AS schema_name, 'Oracle' AS Engine, ( SELECT SUBSTR(BANNER, INSTR(BANNER, ' ') + 1) FROM v$version WHERE BANNER LIKE 'Oracle%' ) AS Version FROM dual","SELECT UPPER('<<POSTGRES_SCHEMA_NAME>>') AS SCHEMA_NAME, 'PostgreSQL' AS Engine, split_part(version(), ' ', 1) || ' ' || split_part(version(), ' ', 2) AS Version",schema_name,both
Database Configuration,Schema Size,"SELECT '<<ORACLE_SCHEMA_NAME>>' AS owner, ROUND(SUM(bytes / 1024 / 1024 / 1024), 2) AS total_size_gb FROM dba_segments WHERE owner = '<<ORACLE_SCHEMA_NAME>>' GROUP BY owner","select upper(schemaname) as owner, round(sum(pg_total_relation_size(schemaname||'.'||tablename))/1024/1024/1024,0) total_size_gb from pg_tables where schemaname=lower('<<POSTGRES_SCHEMA_NAME>>') group by schemaname",owner,both
Database Configuration,Character Encoding and Collation,"select 'DB' AS owner, 'Oracle' as engine, value  as characterset from v$nls_parameters where parameter='NLS_CHARACTERSET'","select 'DB' as owner, 'PostgreSQL' as engine, 'Encoding = '||pg_encoding_to_char(encoding)||', Collation = '|| datcollate as characterset FROM pg_database WHERE datname = current_database()",owner,both
Missing Target Database Table Partition Details,This section provides the table partitions that exist in Oracle but are missing in PostgreSQL Database.,"select t.owner,t.table_name as object_name, 'TABLE' as object_type, t.partitioned from dba_tables t where t.owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( t.table_name not like 'DR%' and t.table_name not like 'BIN$%' and t.table_name not like 'MLOG$%' ) and t.table_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and t.TEMPORARY != 'Y'","SELECT upper(nsp.nspname) as owner,UPPER(cls.relname) AS object_name, CASE WHEN ( cls.relkind = 'r' AND relispartition = 'no' ) THEN 'TABLE' WHEN ( cls.relkind = 'r' AND relispartition = 'yes' ) THEN 'TABLE PARTITION' WHEN (cls.relkind = 'p') THEN 'TABLE' ELSE cls.relkind :: varchar END AS object_Type, COALESCE(part.partname, 'NO') AS partition_name FROM pg_class cls JOIN pg_namespace nsp ON nsp.oid = cls.relnamespace LEFT JOIN ( SELECT parent.relname AS parent_table, child.relname AS partname FROM pg_inherits JOIN pg_class parent ON pg_inherits.inhparent = parent.oid JOIN pg_class child ON pg_inherits.inhrelid = child.oid ) AS part ON part.parent_table = cls.relname WHERE nsp.nspname = LOWER('<<POSTGRES_SCHEMA_NAME>>') AND nsp.nspname NOT LIKE 'pg_toast%%' AND cls.relkind IN ('r', 'p')","owner,object_name",oracle
Database Indexes Comparison Based on Table,This section identifies those tables where the number of indexes does not match between Oracle and PostgreSQL Database.,"select owner, table_name, count(*) index_cnt from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and index_type != 'LOB' and index_name not like 'I_SNAP$%' and index_name not in ( select index_name from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( table_name in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and generated = 'Y' ) ) and table_name not in ( select table_name from dba_tables where table_name like 'DR$%' or table_name like 'BIN$%' or table_name like 'MLOG$%' or temporary = 'Y' ) group by owner, table_name","select upper(nsp.nspname) owner, upper(ctb.relname) table_name, count(*)::integer index_cnt from pg_class ctb join pg_index ix on ctb.oid = ix.indrelid join pg_class cix on cix.oid = ix.indexrelid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and ctb.relispartition = false and cix.relispartition = false group by nsp.nspname, ctb.relname order by 1","owner,table_name",oracle
Missing Target Database Indexes Details,This section identifies those indexes that exist in Oracle but are missing in PostgreSQL Database for non-partitioned tables.,"select i.owner, i.table_name, i.index_name, i.generated, i.index_type, LISTAGG(NVL(TO_CHAR(tc.column_id, 'FM9999'), '0'), ' ') WITHIN GROUP ( ORDER BY ic.column_position ) AS indkey from dba_indexes i join dba_tables t on t.owner = i.owner and t.table_name = i.table_name and t.partitioned = 'NO' and t.temporary = 'N' left outer join dba_ind_columns ic on i.owner = ic.index_owner and i.index_name = ic.index_name left outer join dba_tab_columns tc on ic.table_owner = tc.owner and ic.table_name = tc.table_name and ic.column_name = tc.column_name where i.owner = upper('<<ORACLE_SCHEMA_NAME>>') and i.index_type != 'LOB' and i.index_name not like 'I_SNAP$%' and ( t.table_name not like 'DR$%' and t.table_name not like 'BIN$%' and t.table_name not like 'MLOG$%' ) and i.index_name not in ( select index_name from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and table_name in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and generated = 'Y' ) group by i.owner, i.table_name, i.index_name, i.generated, i.index_type","select upper(nspname) as owner, upper(ctb.relname) as table_name, upper(cix.relname) as index_name, ix.indkey :: text indkey from pg_class ctb join pg_index ix on ctb.oid = ix.indrelid join pg_class cix on cix.oid = ix.indexrelid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and ctb.relispartition = 'no'","owner,table_name",oracle
Missing Table Partition Indexes,This section identifies those indexes that exist in Oracle but are missing in PostgreSQL Database for Partitioned tables.,"select t.owner, ic.table_name, ic.index_name, LISTAGG(NVL(TO_CHAR(NVL(tc.column_id, 0)), '0'), ' ') WITHIN GROUP ( ORDER BY ic.column_position ) AS indkey from dba_ind_columns ic join dba_tables t on ic.index_owner = t.owner and ic.table_name = t.table_name and t.partitioned = 'YES' and t.temporary = 'N' left outer join dba_tab_columns tc on ic.table_owner = tc.owner and ic.table_name = tc.table_name and ic.column_name = tc.column_name where ic.index_owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( t.table_name not like 'DR$%' and t.table_name not like 'BIN$%' and t.table_name not like 'MLOG$%' ) and ic.index_name not like 'I_SNAP$%' and ic.index_name not in ( select index_name from dba_indexes where owner = upper('<<ORACLE_SCHEMA_NAME>>') and table_name in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and generated = 'Y' ) group by t.owner, ic.table_name, ic.index_name","select upper(nspname) as owner, ctb.relname as table_name, cix.relname as index_name, ix.indkey :: text indkey, ctb.relispartition from pg_class ctb join pg_index ix on ctb.oid = ix.indrelid join pg_class cix on cix.oid = ix.indexrelid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,table_name",oracle
Missing Target Database Table Column details,This section identifies the columns of a table that exist in Oracle but are missing in PostgreSQL Database.,"select tc.owner, tc.table_name, tc.column_name, tc.column_id from dba_tab_columns tc join dba_tables t on tc.owner = t.owner and tc.table_name = t.table_name and t.temporary = 'N' where tc.owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( tc.table_name not like 'DR$%' and tc.table_name not like 'BIN$%' and tc.table_name not like 'MLOG$%' ) and t.table_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') )","select upper(nspname) as owner, upper(ctb.relname) as table_name, upper(att.attname) as column_name, att.attnum as column_id from pg_class ctb join pg_attribute att on att.attrelid = ctb.oid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and att.attnum >= 1","owner,table_name",oracle
Missing Target Database Sequence,This section identifies the sequences that exist in Oracle but are missing in PostgreSQL Database.,"select sequence_owner AS owner, sequence_name, last_number from dba_sequences where sequence_owner = upper('<<ORACLE_SCHEMA_NAME>>')","select UPPER(ns.nspname) AS owner, UPPER(sequencename) AS sequence_name, COALESCE(last_value, start_value) AS last_number FROM pg_sequences JOIN pg_namespace ns ON pg_sequences.schemaname = ns.nspname WHERE schemaname = LOWER('<<POSTGRES_SCHEMA_NAME>>')","owner,sequence_name",oracle
Database Constraint - Missing Target Database Primary key,This section identifies the Primary Key constraint that exist in Oracle but are missing in PostgreSQL Database.,"SELECT UPPER(c.owner) AS owner, c.table_name, c.constraint_name, '[' || LISTAGG(NVL(t.column_id, 0), ',') WITHIN GROUP ( ORDER BY c.position ) || ']' AS conkey FROM ( SELECT cl.owner, cl.table_name, cl.constraint_name, cs.constraint_type, cl.column_name, cl.position FROM dba_constraints cs JOIN dba_cons_columns cl ON cs.owner = cl.owner AND cs.constraint_name = cl.constraint_name WHERE cs.owner = UPPER('<<ORACLE_SCHEMA_NAME>>') AND cs.constraint_type IN ('P') ) c JOIN ( SELECT tc.owner, tc.table_name, tc.column_name, tc.column_id FROM dba_tables t JOIN dba_tab_columns tc ON t.owner = tc.owner AND t.table_name = tc.table_name WHERE t.owner = UPPER('<<ORACLE_SCHEMA_NAME>>') AND t.temporary = 'N' AND ( t.table_name NOT LIKE 'DR$%' AND t.table_name NOT LIKE 'BIN$%' AND t.table_name NOT LIKE 'MLOG$%' ) AND t.table_name NOT IN ( SELECT mview_name FROM dba_mviews WHERE owner = UPPER('<<ORACLE_SCHEMA_NAME>>') ) ) t ON t.owner = c.owner AND t.table_name = c.table_name AND c.column_name = t.column_name GROUP BY c.owner, c.table_name, c.constraint_name","select upper(nspname) as owner, upper(cls.relname) table_name, upper(cons.conname) constraint_name, upper(cons.conkey :: text) conkey from pg_constraint cons join pg_class cls on cons.conrelid = cls.oid join pg_namespace nsp on nsp.oid = cls.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,table_name",oracle
Database Constraint - Missing Target Database Foreign Reference,This section identifies the Foreign Key constraint that exist in Oracle but are missing in PostgreSQL Database.,"SELECT c.owner, c.table_name AS table_name, c.constraint_name, '[' || LISTAGG( NVL(TO_CHAR(NVL(cl.position, 0)), '0'), ',' ) WITHIN GROUP ( ORDER BY cl.position ) || ']' AS conkey, '[' || LISTAGG( NVL(cl.column_name, ''), ',' ) WITHIN GROUP ( ORDER BY cl.position ) || ']' AS cons_col FROM dba_constraints c JOIN dba_cons_columns cl ON c.owner = cl.owner AND c.constraint_name = cl.constraint_name JOIN dba_tables t ON t.owner = c.owner AND t.table_name = c.table_name WHERE c.owner = UPPER('<<ORACLE_SCHEMA_NAME>>') AND c.CONSTRAINT_TYPE IN ('R') AND ( t.table_name NOT LIKE 'DR$%' AND t.table_name NOT LIKE 'BIN$%' AND t.table_name NOT LIKE 'MLOG$%' ) GROUP BY c.owner, c.table_name, c.constraint_name","select upper(nspname) as owner, upper(cls.relname) table_name, upper(cons.conname) constraint_name, cons.conkey :: text conkey from pg_constraint cons join pg_class cls on cons.conrelid = cls.oid join pg_namespace nsp on nsp.oid = cls.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,table_name",oracle
Database Constraint - Missing Nullable Constraints,This section identifies the Null Column constraint that exist in Oracle but are missing/mismatch in PostgreSQL Database.,"select tc.owner AS owner, tc.table_name, tc.column_name, case when tc.nullable = 'Y' then 'Yes' else 'No' end as Null_constraint from dba_tab_columns tc join dba_tables t on tc.owner = t.owner and tc.table_name = t.table_name and t.temporary = 'N' where tc.owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( tc.table_name not like 'DR$%' and tc.table_name not like 'BIN$%' and tc.table_name not like 'MLOG$%' ) and t.table_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') )","select upper(nspname) as owner, upper(ctb.relname) as table_name, upper(att.attname) as column_name from pg_class ctb join pg_attribute att on att.attrelid = ctb.oid join pg_namespace nsp on nsp.oid = ctb.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and att.attnum >= 1","owner,table_name",oracle
Database Constraint - Mismatch Default Constraints,This section identifies count of Columns with default constraint for a table that exist in Oracle Database but do not match with the table in PostgreSQL Database.,"select tc.owner, tc.table_name, count(*) cnt from dba_tab_columns tc join dba_tables t on tc.owner = t.owner and tc.table_name = t.table_name and t.temporary = 'N' where tc.owner = upper('<<ORACLE_SCHEMA_NAME>>') and ( tc.table_name not like 'DR$%' and tc.table_name not like 'BIN$%' and tc.table_name not like 'MLOG$%' ) and t.table_name not in ( select mview_name from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>') ) and tc.data_default is not null group by tc.owner, tc.table_name","select table_schema as owner, table_name, count(*)::integer cnt from information_schema.columns where table_schema = lower('<<POSTGRES_SCHEMA_NAME>>') and column_default is not null group by table_schema, table_name","owner,table_name",oracle
Materialized View,This section identifies Materilized Views in Oracle Database that do not exist/match in PostgreSQL Database.,"select owner, mview_name, refresh_method from dba_mviews where owner = upper('<<ORACLE_SCHEMA_NAME>>')","select nspname AS owner, matviewname AS mview_name, 'COMPLETE' AS refresh_method from pg_namespace join pg_matviews ON nspname = schemaname where nspname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,mview_name",oracle
Type,This section identifies Type in Oracle Database that do not exist/match in PostgreSQL Database.,"select owner, object_name, status from dba_objects where owner = upper('<<ORACLE_SCHEMA_NAME>>') and object_type = 'TYPE'","select upper(nspname) as owner, cls.relname object_name from pg_class cls join pg_namespace nsp ON nsp.oid = cls.relnamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>') and cls.relkind = 'c'","owner,object_name",oracle
View,This section identifies Views in Oracle Database that do not exist/match in PostgreSQL Database.,"SELECT owner, object_name, status FROM dba_objects WHERE owner = upper('<<ORACLE_SCHEMA_NAME>>') AND object_type = 'VIEW'","SELECT 'dms_sample' as owner, viewname object_name FROM pg_views WHERE schemaname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,object_name",oracle
Trigger,This section identifies Triggers in Oracle Database that do not exist/match in PostgreSQL Database.,"SELECT UPPER(owner) AS owner, object_name, status FROM dba_objects WHERE owner = upper('<<ORACLE_SCHEMA_NAME>>') AND object_type = 'TRIGGER'","select upper(nspname) as owner, upper(trigger_name) AS object_name FROM information_schema.triggers JOIN pg_namespace nsp ON nsp.nspname = event_object_schema JOIN pg_trigger ON tgname = trigger_name AND nspname = trigger_schema WHERE event_object_schema = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,object_name",oracle
Procedures and Functions,This section identifies procedures and functions in Oracle Database that do not exist in PostgreSQL Database.,"select owner, object_type, object_name, status from dba_objects where owner = upper('<<ORACLE_SCHEMA_NAME>>') and object_type in ('FUNCTION', 'PROCEDURE')","select upper(nspname) as owner, case when pr.prokind = 'p' then 'procedure' else 'function' end as object_type, pr.proname object_name from pg_proc pr join pg_namespace nsp on nsp.oid = pr.pronamespace where nsp.nspname = lower('<<POSTGRES_SCHEMA_NAME>>')","owner,object_type",oracle